/**
 * Extension scaffold generator — produces a complete Chrome Extension directory.
 *
 * Copies the extension template, injects generated tool files, and wires
 * content_scripts entries per URL pattern into manifest.json.
 */
import { writeFileSync, mkdirSync, copyFileSync, existsSync } from "node:fs";
import { join, dirname, resolve } from "node:path";
import { fileURLToPath } from "node:url";
import type { GeneratedFile, ToolManifest, ToolProposal } from "../analysis/types.js";
import { toMatchPattern } from "./generate-manifest.js";

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

/** Path to the extension template directory. */
function getTemplatePath(): string {
  // Resolve relative to the package root, handling both dev and installed scenarios
  const candidates = [
    resolve(__dirname, "../../extension-template"),
    resolve(__dirname, "../extension-template"),
    resolve(__dirname, "../../../extension-template"),
  ];
  for (const candidate of candidates) {
    if (existsSync(candidate)) return candidate;
  }
  return candidates[0]!; // fallback
}

export interface GenerateExtensionOptions {
  /** Name for the extension (appears in Chrome). */
  name?: string;
  /** Extension description. */
  description?: string;
  /** Extension version. */
  version?: string;
  /** Whether the tools need MAIN world access (for JS-call tools). */
  needsMainWorld?: boolean;
}

/**
 * Generate a complete Chrome Extension directory from tool proposals and manifest.
 *
 * @param manifest - URL pattern → tool file mapping.
 * @param toolFiles - Generated tool definition files.
 * @param outputDir - Directory to write the extension to.
 * @param options - Extension configuration.
 */
export function generateExtension(
  manifest: ToolManifest,
  toolFiles: GeneratedFile[],
  proposals: ToolProposal[],
  outputDir: string,
  options: GenerateExtensionOptions = {},
): void {
  const {
    name = manifest.extensionName,
    description = `WebMCP tools generated by webmcp-extend: ${manifest.toolNames.join(", ")}`,
    version = manifest.version,
    needsMainWorld = proposals.some((p) => p.actionType === "js-call"),
  } = options;

  // Create output directory structure
  mkdirSync(join(outputDir, "tools"), { recursive: true });
  mkdirSync(join(outputDir, "src"), { recursive: true });

  // Write generated tool files
  for (const file of toolFiles) {
    const filePath = join(outputDir, file.path);
    mkdirSync(dirname(filePath), { recursive: true });
    writeFileSync(filePath, file.content, "utf-8");
  }

  // Generate the all-tools barrel file
  const barrelContent = generateBarrelFile(manifest.toolNames);
  writeFileSync(join(outputDir, "tools", "index.ts"), barrelContent, "utf-8");

  // Copy template files
  copyTemplateFile("background.ts", join(outputDir, "src", "background.ts"), manifest);
  copyTemplateFile("content-script.ts", join(outputDir, "src", "content-script.ts"), manifest);
  copyTemplateFile("nudge-banner.ts", join(outputDir, "src", "nudge-banner.ts"), manifest);
  if (needsMainWorld) {
    copyTemplateFile("injector-main-world.ts", join(outputDir, "src", "injector-main-world.ts"), manifest);
  }

  // Generate manifest.json
  const manifestJson = generateManifestJson(manifest, {
    name,
    description,
    version,
    needsMainWorld,
  });
  writeFileSync(
    join(outputDir, "manifest.json"),
    JSON.stringify(manifestJson, null, 2),
    "utf-8",
  );

  // Generate package.json for the extension
  const packageJson = generateExtensionPackageJson(name, version);
  writeFileSync(
    join(outputDir, "package.json"),
    JSON.stringify(packageJson, null, 2),
    "utf-8",
  );

  // Generate vite.config.ts for building the extension
  const viteConfig = generateExtensionViteConfig(needsMainWorld);
  writeFileSync(join(outputDir, "vite.config.ts"), viteConfig, "utf-8");

  // Generate tsconfig.json for the extension
  const tsConfig = generateExtensionTsConfig();
  writeFileSync(
    join(outputDir, "tsconfig.json"),
    JSON.stringify(tsConfig, null, 2),
    "utf-8",
  );

  // Write the tool manifest
  writeFileSync(
    join(outputDir, "tool-manifest.json"),
    JSON.stringify(manifest, null, 2),
    "utf-8",
  );
}

// ─── Barrel File ───────────────────────────────────────────────────────────────

function generateBarrelFile(toolNames: string[]): string {
  const imports = toolNames
    .map((name) => `import "./${name}.js";`)
    .join("\n");

  return `/**
 * Auto-generated tool barrel file.
 * Imports all tool definitions, which self-register on load.
 *
 * Generated by webmcp-extend.
 */
${imports}

export const TOOL_NAMES = ${JSON.stringify(toolNames, null, 2)};
`;
}

// ─── Manifest.json ─────────────────────────────────────────────────────────────

interface ManifestJsonOptions {
  name: string;
  description: string;
  version: string;
  needsMainWorld: boolean;
}

function generateManifestJson(
  manifest: ToolManifest,
  options: ManifestJsonOptions,
): Record<string, unknown> {
  const contentScripts: Array<Record<string, unknown>> = [];

  // Content script entries per URL pattern
  for (const pattern of Object.keys(manifest.patterns)) {
    const matchPattern = toMatchPattern(pattern);

    // ISOLATED world content script (tool registration)
    contentScripts.push({
      matches: [matchPattern],
      js: ["dist/content-script.js"],
      run_at: "document_idle",
    });

    // MAIN world injector (for JS-call tools)
    if (options.needsMainWorld) {
      contentScripts.push({
        matches: [matchPattern],
        js: ["dist/injector-main-world.js"],
        world: "MAIN",
        run_at: "document_idle",
      });
    }
  }

  return {
    manifest_version: 3,
    name: options.name,
    description: options.description,
    version: options.version,
    permissions: ["activeTab"],
    background: {
      service_worker: "dist/background.js",
      type: "module",
    },
    content_scripts: contentScripts,
    icons: {},
  };
}

// ─── Template Copying ──────────────────────────────────────────────────────────

function copyTemplateFile(
  templateName: string,
  destPath: string,
  _manifest: ToolManifest,
): void {
  const templatePath = join(getTemplatePath(), templateName);
  if (existsSync(templatePath)) {
    copyFileSync(templatePath, destPath);
  } else {
    // Write a placeholder if template doesn't exist yet
    writeFileSync(
      destPath,
      `// Template file: ${templateName}\n// TODO: Copy from extension-template\n`,
      "utf-8",
    );
  }
}

// ─── Extension package.json ────────────────────────────────────────────────────

function generateExtensionPackageJson(
  name: string,
  version: string,
): Record<string, unknown> {
  return {
    name,
    version,
    private: true,
    type: "module",
    scripts: {
      build: "vite build",
      watch: "vite build --watch",
    },
    dependencies: {
      "webmcp-kit": "^0.1.1",
    },
    devDependencies: {
      vite: "^6.1.0",
      typescript: "^5.7.0",
      zod: "^4.0.0",
    },
  };
}

// ─── Extension Vite Config ─────────────────────────────────────────────────────

function generateExtensionViteConfig(needsMainWorld: boolean): string {
  const entries = [
    `      background: resolve(__dirname, "src/background.ts"),`,
    `      "content-script": resolve(__dirname, "src/content-script.ts"),`,
    `      "nudge-banner": resolve(__dirname, "src/nudge-banner.ts"),`,
  ];

  if (needsMainWorld) {
    entries.push(
      `      "injector-main-world": resolve(__dirname, "src/injector-main-world.ts"),`,
    );
  }

  return `import { defineConfig } from "vite";
import { resolve } from "node:path";

export default defineConfig({
  build: {
    rollupOptions: {
      input: {
${entries.join("\n")}
      },
      output: {
        entryFileNames: "[name].js",
        format: "iife",
      },
    },
    outDir: "dist",
    emptyOutDir: true,
    target: "chrome120",
    minify: false,
  },
});
`;
}

// ─── Extension tsconfig.json ───────────────────────────────────────────────────

function generateExtensionTsConfig(): Record<string, unknown> {
  return {
    compilerOptions: {
      target: "ES2022",
      module: "ESNext",
      moduleResolution: "bundler",
      lib: ["ES2022", "DOM", "DOM.Iterable"],
      strict: true,
      esModuleInterop: true,
      skipLibCheck: true,
      forceConsistentCasingInFileNames: true,
      isolatedModules: true,
      types: ["chrome"],
    },
    include: ["src/**/*.ts", "tools/**/*.ts"],
  };
}
