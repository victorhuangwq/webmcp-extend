/**
 * Content script (ISOLATED world) â€” registers auto-generated WebMCP tools.
 *
 * This script runs in the extension's isolated world. It:
 * 1. Imports bundled tool definitions (which self-register via defineTool().register())
 * 2. Checks for native WebMCP support (navigator.modelContext)
 * 3. Falls back to webmcp-kit's mock layer if needed
 * 4. Communicates with the MAIN world injector via postMessage for JS-call tools
 * 5. Unregisters tools on page unload
 *
 * Generated by webmcp-extend.
 */

// The tool barrel file is imported by the bundler â€” all tools self-register
// import "../tools/index.js";

// â”€â”€â”€ Types â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

interface WebMCPExtendMessage {
  type: "webmcp-extend";
  action: string;
  payload?: unknown;
  requestId?: string;
}

// â”€â”€â”€ Initialization â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

/**
 * Initialize tool registration.
 */
async function initialize(): Promise<void> {
  console.log("[webmcp-extend] Initializing tool registration...");

  // Check for native WebMCP support
  const hasNativeSupport = "modelContext" in navigator && navigator.modelContext != null;

  if (hasNativeSupport) {
    console.log("[webmcp-extend] Native WebMCP support detected â€” tools will register via navigator.modelContext");
  } else {
    console.log("[webmcp-extend] No native WebMCP support â€” using webmcp-kit mock layer");
    // webmcp-kit's defineTool().register() automatically falls back to mock
  }

  // Notify background script that tools are registered
  try {
    chrome.runtime.sendMessage({
      type: "webmcp-extend",
      action: "tools-registered",
    });
  } catch {
    // Extension context may be invalid
  }

  // Show the nudge banner (if not dismissed)
  injectNudgeBanner();
}

// â”€â”€â”€ Main World Communication â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

// Pending requests to the MAIN world injector
const pendingRequests = new Map<
  string,
  { resolve: (value: unknown) => void; reject: (reason: unknown) => void }
>();

/**
 * Send a request to the MAIN world injector to call a page JS function.
 *
 * @param functionPath - The global function path (e.g., "window.addToCart").
 * @param args - Arguments to pass to the function.
 * @returns The function's return value.
 */
export function callPageFunction(
  functionPath: string,
  args: unknown[],
): Promise<unknown> {
  return new Promise((resolve, reject) => {
    const requestId = `webmcp-${Date.now()}-${Math.random().toString(36).slice(2)}`;

    pendingRequests.set(requestId, { resolve, reject });

    // Send to MAIN world via postMessage
    window.postMessage(
      {
        type: "webmcp-extend",
        action: "call-function",
        payload: { functionPath, args },
        requestId,
      } satisfies WebMCPExtendMessage,
      "*",
    );

    // Timeout after 10 seconds
    setTimeout(() => {
      if (pendingRequests.has(requestId)) {
        pendingRequests.delete(requestId);
        reject(new Error(`Timeout calling ${functionPath}`));
      }
    }, 10_000);
  });
}

// Listen for responses from MAIN world
window.addEventListener("message", (event) => {
  if (event.source !== window) return;

  const data = event.data as WebMCPExtendMessage;
  if (data?.type !== "webmcp-extend") return;

  if (data.action === "function-result" && data.requestId) {
    const pending = pendingRequests.get(data.requestId);
    if (pending) {
      pendingRequests.delete(data.requestId);
      const result = data.payload as { success: boolean; value?: unknown; error?: string };
      if (result.success) {
        pending.resolve(result.value);
      } else {
        pending.reject(new Error(result.error ?? "Unknown error"));
      }
    }
  }
});

// â”€â”€â”€ Nudge Banner â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

function injectNudgeBanner(): void {
  // Check localStorage for dismissal
  const dismissed = localStorage.getItem("webmcp-extend-banner-dismissed");
  if (dismissed === "true") return;

  const banner = document.createElement("div");
  banner.id = "webmcp-extend-nudge";
  banner.innerHTML = `
    <div style="
      position: fixed;
      bottom: 16px;
      right: 16px;
      z-index: 2147483647;
      background: #1a1a2e;
      color: #e0e0e0;
      padding: 12px 16px;
      border-radius: 8px;
      font-family: system-ui, -apple-system, sans-serif;
      font-size: 13px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.3);
      display: flex;
      align-items: center;
      gap: 8px;
      max-width: 380px;
      border: 1px solid #333;
    ">
      <span style="flex: 1;">
        ðŸ”§ Tools auto-generated by <strong>webmcp-extend</strong>.
        <a href="https://github.com/nicholasgriffintn/webmcp-kit"
           target="_blank"
           style="color: #64b5f6; text-decoration: none;">
          Go native with webmcp-kit â†’
        </a>
      </span>
      <button id="webmcp-extend-dismiss" style="
        background: none;
        border: none;
        color: #888;
        cursor: pointer;
        font-size: 16px;
        padding: 0 4px;
        line-height: 1;
      ">âœ•</button>
    </div>
  `;
  document.body.appendChild(banner);

  document.getElementById("webmcp-extend-dismiss")?.addEventListener("click", () => {
    banner.remove();
    localStorage.setItem("webmcp-extend-banner-dismissed", "true");
  });
}

// â”€â”€â”€ Lifecycle â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

// Listen for deactivation from background script
chrome.runtime.onMessage.addListener((message) => {
  if (message.type === "webmcp-extend" && message.action === "deactivate") {
    console.log("[webmcp-extend] Deactivating tools");
    // Tools will be cleaned up when the page unloads
    const banner = document.getElementById("webmcp-extend-nudge");
    if (banner) banner.remove();
  }
});

// Clean up on page unload
window.addEventListener("beforeunload", () => {
  console.log("[webmcp-extend] Page unloading â€” tools will be unregistered");
  // webmcp-kit handles unregistration via the mock context
});

// Initialize on load
initialize();
