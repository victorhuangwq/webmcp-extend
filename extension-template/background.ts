/**
 * Background service worker for the WebMCP Extend Chrome Extension.
 *
 * Listens for tab URL changes, enables/disables tool injection
 * per URL pattern. Manages tool lifecycle across navigations.
 *
 * Generated by webmcp-extend.
 */

// URL patterns configured by the generator — maps pattern to content script IDs
declare const WEBMCP_EXTEND_PATTERNS: Record<string, string[]>;

interface ToolRegistration {
  tabId: number;
  patterns: string[];
  active: boolean;
}

// Track which tabs have active tool registrations
const activeRegistrations = new Map<number, ToolRegistration>();

// ─── Tab URL Change Listener ───────────────────────────────────────────────────

chrome.tabs.onUpdated.addListener((tabId, changeInfo, tab) => {
  if (changeInfo.status !== "complete" || !tab.url) return;

  const matchingPatterns = getMatchingPatterns(tab.url);

  if (matchingPatterns.length > 0) {
    // URL matches — tools should be active
    activeRegistrations.set(tabId, {
      tabId,
      patterns: matchingPatterns,
      active: true,
    });

    // Notify content script to register tools
    chrome.tabs.sendMessage(tabId, {
      type: "webmcp-extend",
      action: "activate",
      patterns: matchingPatterns,
    }).catch(() => {
      // Content script may not be loaded yet — that's OK,
      // it will self-activate based on manifest content_scripts
    });
  } else {
    // URL doesn't match — deactivate tools if they were active
    const existing = activeRegistrations.get(tabId);
    if (existing?.active) {
      chrome.tabs.sendMessage(tabId, {
        type: "webmcp-extend",
        action: "deactivate",
      }).catch(() => {
        // Tab may have navigated away
      });
      activeRegistrations.delete(tabId);
    }
  }
});

// Clean up when a tab is closed
chrome.tabs.onRemoved.addListener((tabId) => {
  activeRegistrations.delete(tabId);
});

// ─── URL Pattern Matching ──────────────────────────────────────────────────────

/**
 * Check which configured URL patterns match the given URL.
 */
function getMatchingPatterns(url: string): string[] {
  // If WEBMCP_EXTEND_PATTERNS is defined (injected by generator), use it
  if (typeof WEBMCP_EXTEND_PATTERNS !== "undefined") {
    return Object.keys(WEBMCP_EXTEND_PATTERNS).filter((pattern) =>
      matchesPattern(url, pattern),
    );
  }
  // Fallback: match all URLs (for development/testing)
  return ["<all_urls>"];
}

/**
 * Test whether a URL matches a Chrome extension match pattern.
 *
 * Supports patterns like:
 *   - "*://example.com/*"
 *   - "https://example.com/products/*"
 *   - "<all_urls>"
 */
function matchesPattern(url: string, pattern: string): boolean {
  if (pattern === "<all_urls>") return true;

  try {
    // Convert match pattern to regex
    const regexStr = pattern
      .replace(/[.+?^${}()|[\]\\]/g, "\\$&") // Escape regex chars (except *)
      .replace(/\\\*/g, ".*"); // Convert * to .*

    // Handle scheme wildcard
    const finalRegex = regexStr.replace(/^\\\*:/, "(https?|file|ftp):");
    return new RegExp(`^${finalRegex}$`).test(url);
  } catch {
    return false;
  }
}

// ─── Message Handler ───────────────────────────────────────────────────────────

chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
  if (message.type !== "webmcp-extend") return;

  switch (message.action) {
    case "get-status": {
      const tabId = sender.tab?.id;
      if (tabId) {
        const registration = activeRegistrations.get(tabId);
        sendResponse({
          active: registration?.active ?? false,
          patterns: registration?.patterns ?? [],
        });
      }
      break;
    }

    case "tools-registered": {
      // Content script confirms tools are registered
      const tabId = sender.tab?.id;
      if (tabId) {
        const registration = activeRegistrations.get(tabId);
        if (registration) {
          registration.active = true;
        }
      }
      break;
    }
  }

  return true; // Keep message channel open for async responses
});
