/**
 * Main world injector — executes page JS function calls on behalf
 * of the ISOLATED world content script.
 *
 * This script runs in the page's MAIN world, giving it access to
 * the page's JavaScript context (window.*, global functions, etc.).
 *
 * Communication with the ISOLATED world content script happens via
 * window.postMessage with a { type: "webmcp-extend" } protocol.
 *
 * Generated by webmcp-extend.
 */

// ─── Types ─────────────────────────────────────────────────────────────────────

interface WebMCPExtendMessage {
  type: "webmcp-extend";
  action: string;
  payload?: unknown;
  requestId?: string;
}

interface CallFunctionPayload {
  functionPath: string;
  args: unknown[];
}

// ─── Message Handler ───────────────────────────────────────────────────────────

window.addEventListener("message", (event) => {
  // Only accept messages from the same window (content script)
  if (event.source !== window) return;

  const data = event.data as WebMCPExtendMessage;
  if (data?.type !== "webmcp-extend") return;

  if (data.action === "call-function" && data.requestId) {
    const payload = data.payload as CallFunctionPayload;
    handleFunctionCall(payload, data.requestId);
  }
});

/**
 * Execute a function call in the page's JS context and post the result back.
 */
function handleFunctionCall(
  payload: CallFunctionPayload,
  requestId: string,
): void {
  try {
    const fn = resolveFunctionPath(payload.functionPath);

    if (typeof fn !== "function") {
      postResult(requestId, {
        success: false,
        error: `${payload.functionPath} is not a function (got ${typeof fn})`,
      });
      return;
    }

    // Call the function with the provided arguments
    const result = fn(...payload.args);

    // Handle promises
    if (result && typeof result === "object" && typeof result.then === "function") {
      (result as Promise<unknown>)
        .then((value) => {
          postResult(requestId, { success: true, value: serializeResult(value) });
        })
        .catch((error: unknown) => {
          postResult(requestId, {
            success: false,
            error: error instanceof Error ? error.message : String(error),
          });
        });
    } else {
      postResult(requestId, { success: true, value: serializeResult(result) });
    }
  } catch (error) {
    postResult(requestId, {
      success: false,
      error: error instanceof Error ? error.message : String(error),
    });
  }
}

/**
 * Resolve a dotted function path (e.g., "window.app.addToCart") to the actual function.
 */
function resolveFunctionPath(path: string): unknown {
  const parts = path.split(".");
  let current: unknown = window;

  // Skip "window." prefix if present
  const startIndex = parts[0] === "window" ? 1 : 0;

  for (let i = startIndex; i < parts.length; i++) {
    if (current == null || typeof current !== "object") {
      throw new Error(
        `Cannot resolve ${path}: ${parts.slice(0, i).join(".")} is ${typeof current}`,
      );
    }
    current = (current as Record<string, unknown>)[parts[i]!];
  }

  return current;
}

/**
 * Serialize a result value for postMessage transfer.
 * Handles common cases: primitives, plain objects, arrays.
 * Falls back to string representation for unserializable values.
 */
function serializeResult(value: unknown): unknown {
  if (value === null || value === undefined) return value;

  const type = typeof value;
  if (type === "string" || type === "number" || type === "boolean") return value;

  try {
    // Try JSON round-trip to ensure serializable
    return JSON.parse(JSON.stringify(value));
  } catch {
    return String(value);
  }
}

/**
 * Post a function call result back to the ISOLATED world content script.
 */
function postResult(
  requestId: string,
  result: { success: boolean; value?: unknown; error?: string },
): void {
  window.postMessage(
    {
      type: "webmcp-extend",
      action: "function-result",
      payload: result,
      requestId,
    } satisfies WebMCPExtendMessage,
    "*",
  );
}

// Signal that the MAIN world injector is ready
window.postMessage(
  {
    type: "webmcp-extend",
    action: "injector-ready",
  },
  "*",
);

console.log("[webmcp-extend] MAIN world injector loaded");
